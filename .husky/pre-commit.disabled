#!/bin/sh

# Pre-commit hook to prevent direct commits to domain paths on main branch
# Reads domain path ownership from .github/domain-paths.yaml

set -e

DOMAIN_PATHS_FILE=".github/domain-paths.yaml"

# Get current branch name
BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Only check on main branch
if [ "$BRANCH" = "main" ]; then
    # Check if yq is available
    if ! command -v yq >/dev/null 2>&1; then
        printf "⚠️  Warning: 'yq' is not installed. Skipping domain path check.\n"
        printf "   Install yq to enable this pre-commit hook: https://github.com/mikefarah/yq\n"
        exit 0
    fi

    # Check if domain-paths.yaml exists
    if [ ! -f "$DOMAIN_PATHS_FILE" ]; then
        printf "⚠️  Warning: '%s' not found. Skipping domain path check.\n" "$DOMAIN_PATHS_FILE"
        exit 0
    fi

    # Extract paths from YAML using yq (one per line)
    PROTECTED_PATHS=$(yq eval '.domains.*.paths[]' "$DOMAIN_PATHS_FILE" 2>/dev/null)

    if [ -z "$PROTECTED_PATHS" ]; then
        exit 0
    fi

    # Get list of staged files
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

    if [ -n "$STAGED_FILES" ]; then
        # Iterate files and patterns line-by-line to preserve spaces and special chars
        printf '%s\n' "$STAGED_FILES" | while IFS= read -r file; do
            printf '%s\n' "$PROTECTED_PATHS" | while IFS= read -r pattern; do
                # Normalize pattern: remove trailing '/**' if present
                case "$pattern" in
                    */**) prefix=${pattern%/**} ;;
                    *) prefix=$pattern ;;
                esac

                # Check if file path starts with the prefix (exact match or under the directory)
                case "$file" in
                    "$prefix" | "$prefix"/*)
                        printf "\n❌ Commit blocked: Direct commits to '%s' are not allowed on 'main' branch.\n\n" "$prefix"
                        printf "Please create a feature branch for changes to this domain.\n\n"
                        exit 1
                        ;;
                esac
            done
        done

        # If any inner loop exited with non-zero, propagate failure (while runs in subshell for some shells)
        if [ $? -ne 0 ]; then
            exit 1
        fi
    fi
fi

exit 0
