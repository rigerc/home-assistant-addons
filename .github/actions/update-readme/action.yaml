---
name: README Updates
description: "Update all or given READMEs"

inputs:
  addons:
    description: Addon-Name(s)
    required: false

runs:
  using: "composite"
  steps:
    - name: ‚ÑπÔ∏è Gather Addon Info
      id: info
      shell: bash
      run: |
        data=()
        readme=()
        for directory in $(find ./ -maxdepth 2 -name config.json -o -name config.yaml -o -name config.yml | cut -d "/" -f2 | sort -u); do
          # Extract base image from Dockerfile (handle various patterns)
          base_image=""
          dockerfile="${directory}/Dockerfile"
          if [[ -f "$dockerfile" ]]; then
            # Look for BASE_IMAGE ARG or extract from first FROM statement with AS
            base_image=$(grep -E '^ARG BASE_IMAGE=' "$dockerfile" | sed 's/^ARG BASE_IMAGE=//' | tr -d '"')
            if [[ -z "$base_image" ]]; then
              # Extract from first FROM statement (e.g., "FROM image:tag AS name" or "FROM image:tag")
              base_image=$(grep -m1 '^FROM ' "$dockerfile" | sed -E 's/^FROM[[:space:]]+([^[:space:]]+).*/\1/')
            fi
          fi

          # Parse upstream version from base image (e.g., "v1.1.3" from "repo/image:v1.1.3")
          upstream_version=""
          upstream_image_repo=""
          upstream_badge_type=""
          if [[ -n "$base_image" ]]; then
            upstream_version=$(echo "$base_image" | grep -oE ':[^[:space:]]+' | tr -d ':')
            # Extract image repository without tag (e.g., "ghcr.io/user/repo" or "user/repo")
            upstream_image_repo=$(echo "$base_image" | sed 's/:[^[:space:]]*//')
            # Determine badge type based on registry
            if [[ "$upstream_image_repo" =~ ^ghcr\.io/ ]]; then
              upstream_badge_type="github"
              # Extract owner/repo from ghcr.io/owner/repo
              upstream_image_repo=$(echo "$upstream_image_repo" | sed 's|^ghcr\.io/||')
            else
              upstream_badge_type="docker"
            fi
          fi

          # Compare versions and generate status badge JSON
          if [[ -n "$upstream_image_repo" && -n "$upstream_version" ]]; then
            # Fetch latest upstream version
            latest_version=""
            if [[ "$upstream_badge_type" == "github" ]]; then
              latest_version=$(gh api repos/${upstream_image_repo}/releases/latest --jq .tag_name 2>/dev/null || echo "")
            elif [[ "$upstream_badge_type" == "docker" ]]; then
              latest_version=$(curl -s "https://hub.docker.com/v2/repositories/${upstream_image_repo}/tags?page_size=1&ordering=-last_updated" | jq -r '.results[0].name' 2>/dev/null || echo "")
            fi

            # Normalize versions (remove common prefixes)
            normalize_version() {
              echo "$1" | sed -E 's/^(v|version-|rel-)//' | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/'
            }

            current_normalized=$(normalize_version "$upstream_version")
            latest_normalized=$(normalize_version "$latest_version")

            # Default values
            badge_color="lightgrey"
            badge_message="unknown"
            comparison_result="unknown"

            if [[ -n "$latest_normalized" && -n "$current_normalized" ]]; then
              if [[ "$current_normalized" == "$latest_normalized" ]]; then
                badge_color="brightgreen"
                badge_message="up-to-date ‚úì"
                comparison_result="up-to-date"
              else
                # Parse semantic versions
                IFS='.' read -r current_major current_minor current_patch <<< "$current_normalized"
                IFS='.' read -r latest_major latest_minor latest_patch <<< "$latest_normalized"

                # Default to 0 if empty
                current_major=${current_major:-0}
                current_minor=${current_minor:-0}
                current_patch=${current_patch:-0}
                latest_major=${latest_major:-0}
                latest_minor=${latest_minor:-0}
                latest_patch=${latest_patch:-0}

                if (( latest_major > current_major )); then
                  badge_color="red"
                  badge_message="outdated ($current_normalized ‚Üí $latest_normalized)"
                  comparison_result="major-behind"
                elif (( latest_major < current_major )); then
                  badge_color="brightgreen"
                  badge_message="up-to-date ‚úì"
                  comparison_result="up-to-date"
                elif (( latest_minor > current_minor )); then
                  versions_behind=$((latest_minor - current_minor))
                  if (( versions_behind >= 4 )); then
                    badge_color="red"
                  elif (( versions_behind >= 2 )); then
                    badge_color="orange"
                  else
                    badge_color="yellow"
                  fi
                  badge_message="$versions_behind version(s) behind"
                  comparison_result="minor-behind"
                elif (( latest_minor < current_minor )); then
                  badge_color="brightgreen"
                  badge_message="up-to-date ‚úì"
                  comparison_result="up-to-date"
                elif (( latest_patch > current_patch )); then
                  badge_color="yellow"
                  badge_message="patch available"
                  comparison_result="patch-behind"
                else
                  badge_color="brightgreen"
                  badge_message="up-to-date ‚úì"
                  comparison_result="up-to-date"
                fi
              fi
            fi

            # Create .versions directory if it doesn't exist
            mkdir -p .versions

            # Generate JSON file in shields.io endpoint format using jq
            jq -n \
              --arg msg "$badge_message" \
              --arg color "$badge_color" \
              '{
                schemaVersion: 1,
                label: "upstream",
                message: $msg,
                color: $color,
                cacheSeconds: 3600
              }' > ".versions/${directory}.json"
            echo "Generated version status for ${directory}: ${badge_message} (${badge_color})"
          fi

          # Extract project_url from addon_info.json if it exists
          project_url=""
          info_file="${directory}/addon_info.json"
          if [[ -f "$info_file" ]]; then
            project_url=$(jq -r '.project_url // empty' "$info_file" 2>/dev/null || echo "")
          fi

          # Export variables so yq can read them via env()
          export base_image upstream_version project_url upstream_image_repo upstream_badge_type

          addon=$(yq e -N -M '. | {"name": .name, "slug": .slug, "version": .version, "description": .description, "arch": .arch, "base_image": env(base_image), "upstream_version": env(upstream_version), "project_url": env(project_url), "upstream_image_repo": env(upstream_image_repo), "upstream_badge_type": env(upstream_badge_type) }' -o=json -I=0 "${directory}/config.yaml")
          data+=("${addon}");
          readme+=("${directory}");
        done

        if [[ ! -z "${{ inputs.addons }}" ]]; then
          readme=("${{ inputs.addons }}")
        fi

        echo "readme=${readme[@]}" >> $GITHUB_OUTPUT;
        echo "Readme's to update: ${readme[@]}";

        addons=[$(IFS=, ; echo "${data[*]}")]
        echo "addons=${addons}" >> $GITHUB_OUTPUT;
        echo "Resolved addon data: ${addons}";
    - name: üìù Generate README.md
      shell: bash
      env:
        REPOSITORY: ${{ github.repository }}
        REPOSITORY_URL: https://github.com/${{ github.repository }}
        ARCHITECTURES: "['aarch64', 'amd64', 'armhf', 'armv7']"
        ADDONS_DATA: ${{ steps.info.outputs.addons }}
      run: |
        curl -o /usr/local/bin/gomplate -sSL https://github.com/hairyhenderson/gomplate/releases/download/v3.11.5/gomplate_linux-amd64
        chmod 755 /usr/local/bin/gomplate

        # Generate root README.md
        echo "Generating root README.md"
        gomplate --file=.README.tmpl --out=README.md

        # Generate individual add-on READMEs
        for addon in ${{ steps.info.outputs.readme }}; do
          echo "Generating README for ${addon}"
          # Use central template with ADDON_SLUG set to current addon directory
          export ADDON_SLUG="${addon}"
          gomplate --file=.README_ADDON.tmpl --out=${addon}/README.md
        done
